<?xml version="1.0" encoding="UTF-8"?>
<!-- **********************************************************************************************************-->
<!-- SCHEMATRON  SCHEMA FOR FEDORA DIGITAL OBJECTS-->
<!-- TITLE:  fedoraRules.xml -->
<!-- DESCRIPTION:  This schema expresses validation rules for Fedora digital objects that -->
<!-- are NOT ALREADY EXPRESSED in the METS XML Schema.-->
<!-- AUTHOR:  Sandy Payette,  payette@cs.cornell.edu -->
<!-- *********************************************************************************************************-->
<sch:schema xmlns:sch="http://www.ascc.net/xml/schematron">
	<!-- FIGURE OUT: how to best deal with validation and namespace prefix declaration-->
	<sch:ns prefix="METS" uri="http://www.loc.gov/METS/"/>
	<sch:ns prefix="xlink" uri="http://www.w3.org/TR/xlink"/>
	<!-- RULES FOR OBJECT INGEST PHASE:  These rules apply to a digital object in its "submission" format for ingest into the repository-->
	<!-- These rules are to be applied upon initial receipt of the object by the repository, before the repository has done any processing of the input.-->
	<sch:phase id="ingest">
		<sch:active pattern="preliminary"/>
	</sch:phase>
	<!-- RULES FOR OBJECT STORAGE PHASE: Rules to ensure that digital object is FULLY valid before being accepted for final storage in the repository-->
	<!-- These rules are to be applied after all processing has been done by the repository, and before it is submitted to low level storage.-->
	<sch:phase id="store">
		<sch:active pattern="preliminary"/>
		<sch:active pattern="completed"/>
	</sch:phase>
	<!-- PRELIMINARY PATTERN: -->
	<!-- These rules are to be applied to objects no matter what phase of the object lifecycle they are in.-->
	<sch:pattern name="Preliminary Object Checks" id="preliminary">
		<sch:rule context="METS:mets[@TYPE='FedoraBMechObject']">
			<sch:assert test="child::METS:amdSec[@ID='DSBIND']">Behavior Mechanism Objects must have an inline Datastream representing a Datastream Binding Spec (element amdSec with ID="DSBIND" must exist when element mets has TYPE="FedoraBMechObject"</sch:assert>
			<sch:assert test="child::METS:amdSec[@ID='WSDL']">Behavior Mechanism Objects must have an inline Datastream representing WSDL service bindings (element amdSec with ID="WSDL" must exist when element mets has TYPE="FedoraBMechObject"</sch:assert>
		</sch:rule>
		<sch:rule context="METS:mets[@TYPE='FedoraBDefObject']">
			<sch:assert test="child::METS:amdSec[@ID='WSDL']">Behavior Definition Objects must have an inline Datastream representing WSDL abstract method defs (element amdSec with ID="WSDL" must exist when element mets has TYPE="FedoraBDefObject"</sch:assert>
		</sch:rule>
		<sch:rule context="METS:mets">
			<sch:assert test="@TYPE = 'FedoraObject' or @TYPE = 'FedoraBDefObject' or @TYPE = 'FedoraBMechObject'">Object must be of type "FedoraObject|FedoraBDefObject|FedoraBMechObject" (element mets: TYPE)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:fileSec">
			<sch:assert test="METS:fileGrp[@ID]">All Datastreams must have a DatastreamID (element fileGrp: ID is missing or empty)</sch:assert>
			<sch:assert test="METS:fileGrp[@ID='DATASTREAMS']">Datastreams section encoding error (element fileSec: must have child fileGrp whose ID is "DATASTREAMS"</sch:assert>
			<sch:assert test="count(METS:fileGrp) = 1">Datastreams section encoding error (element fileSec: can only have one fileGrp as direct decendant)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:fileGrp">
			<sch:assert test="@ID">Every Datastream must have a DatastreamID (element fileGrp: ID is missing)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:file">
			<sch:assert test="string(@OWNERID)">Datastream control group must be recorded (element file: OWNERID missing or empty)</sch:assert>
			<sch:assert test="@OWNERID = 'P' or @OWNERID = 'E' or @OWNERID = 'M' or @OWNERID = 'X'">Datastream control group must be "P" for Protected-External-Ref, "E" for External-Ref, "M" for Managed-Internal, or "X" for Inline-XML-User-Metadata.  (element file: OWNERID)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:behaviorSec">
			<sch:assert test="string(@GROUPID)">Every Disseminator must have a DisseminatorID (element behaviorSec: GROUPID is missing or empty)</sch:assert>
			<sch:assert test="METS:interfaceDef[string(@xlink:href)]">Disseminator must point to a Behavior Definition Object (element behaviorSec/interfaceDef: xlink:href is missing or empty)</sch:assert>
			<sch:assert test="METS:mechanism[string(@xlink:href)]">Disseminator must point to a Behavior Mechanism Object (element behaviorSec/mechanism: xlink:href is missing or empty)</sch:assert>
		</sch:rule>
	</sch:pattern>
	<!-- COMPLETED PATTERN: -->
	<!-- These rules are to be applied to objects when they are considered completed and ready to be stored persistently in the repository.-->
	<sch:pattern name="Completed Object Checks" id="completed">
		<sch:rule context="METS:metsHdr">
			<sch:assert test="@CREATEDATE">Object must have a date of creation (element header: CREATEDATE missing)</sch:assert>
			<!--			<sch:assert test="string(@RECORDSTATUS)">Object state must be recorded (element header: RECORDSTATUS missing or empty)</sch:assert>
			<sch:assert test="@RECORDSTATUS ='A' or @RECORDSTATUS ='W' or @RECORDSTATUS ='C' or @RECORDSTATUS ='D'">Object state value is invalid  (element header: RECORDSTATUS must be "A|W|C|D")</sch:assert> -->
		</sch:rule>
		<sch:rule context="METS:file">
			<sch:assert test="string(@STATUS)">Datastream state must be recorded (element file: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'W' or @STATUS= 'C' or @STATUS= 'D'">Datastream state must be "A" for Active, "W" for Withdrawn, "C" for Pending Deletion, or "D" for Deleted.  (element file: STATUS)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:behaviorSec">
			<sch:assert test="@CREATEDATE">Disseminator must have a date of creation (element behaviorSec: CREATEDATE missing)</sch:assert>
			<sch:assert test="string(@STATUS)">Disseminator state must be recorded (element behaviorSec: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'W' or @STATUS= 'C' or @STATUS= 'D'">Disseminator state must be "A" for Active, "W" for Withdrawn, "C" for Pending Deletion, or "D" for Deleted.  (element behaviorSec: STATUS)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:dmdSec">
			<sch:assert test="@CREATEDATE">Inline Metadata Datastream must have a date of creation (element dmdSec: CREATEDATE missing)</sch:assert>
			<sch:assert test="string(@STATUS)">Inline Metadata Datastream state must be recorded (element dmdSec: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'W' or @STATUS= 'C' or @STATUS= 'D'">Inline Metadata Datastream state must be "A" for Active, "W" for Withdrawn, "C" for Pending Deletion, or "D" for Deleted.  (element dmdSec: STATUS)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:techMD">
			<sch:assert test="@CREATEDATE">Inline Metadata Datastream must have a date of creation (element techMD: CREATEDATE missing)</sch:assert>
			<sch:assert test="string(@STATUS)">Inline Metadata Datastream state must be recorded (element techMD: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'W' or @STATUS= 'C' or @STATUS= 'D'">Inline Metadata Datastream state must be "A" for Active, "W" for Withdrawn, "C" for Pending Deletion, or "D" for Deleted.  (element techMD: STATUS)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:rightsMD">
			<sch:assert test="@CREATEDATE">Inline Metadata Datastream must have a date of creation (element rightsMD: CREATEDATE missing)</sch:assert>
			<sch:assert test="string(@STATUS)">Inline Metadata Datastream state must be recorded (element rightsMD: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'W' or @STATUS= 'C' or @STATUS= 'D'">Inline Metadata Datastream state must be "A" for Active, "W" for Withdrawn, "C" for Pending Deletion, or "D" for Deleted.  (element rightsMD: STATUS)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:sourceMD">
			<sch:assert test="@CREATEDATE">Inline Metadata Datastream must have a date of creation (element sourceMD: CREATEDATE missing)</sch:assert>
			<sch:assert test="string(@STATUS)">Inline Metadata Datastream state must be recorded (element sourceMD: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'W' or @STATUS= 'C' or @STATUS= 'D'">Inline Metadata Datastream state must be "A" for Active, "W" for Withdrawn, "C" for Pending Deletion, or "D" for Deleted.  (element sourceMD: STATUS)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:digiprovMD">
			<sch:assert test="@CREATEDATE">Inline Metadata Datastream must have a date of creation (element digiprovMD: CREATEDATE missing)</sch:assert>
			<sch:assert test="string(@STATUS)">Inline Metadata Datastream state must be recorded (element digiprovMD: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'W' or @STATUS= 'C' or @STATUS= 'D'">Inline Metadata Datastream state must be "A" for Active, "W" for Withdrawn, "C" for Pending Deletion, or "D" for Deleted.  (element digiprovMD: STATUS)</sch:assert>
		</sch:rule>
	</sch:pattern>
</sch:schema>
